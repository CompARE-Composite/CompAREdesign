dcopula <- dFrank
b10 <- uniroot(Fb10, interval=limits,p1=p1)$root
dcopula <- get(paste0('d',copula))
limits <- c(0.8,1.2)*b10
b10 <- uniroot(Fb10, interval=limits,p1=p1)$root
}
## -- Case 3 --------------------------------------------------------
} else if (case==3) {
b10 <- 1/((-log(1-p1))^(1/beta1))
Fb20 <- function(b20,p2) {
integral<-integrate(function(v) {
sapply(v,function(v) {
integrate(function(u){dcopula(u,v,theta)},lower=1-exp((b20*(-log(1-v))^(1/beta2))^beta1*log(1-p1)),upper=1)$value
})
},
lower=0 , upper=1-exp(-1/b20^beta2))$value
return(integral-p2)
}
limits <- c(0.00001,10000)
b20 <- try(uniroot(Fb20, interval=limits,p2=p2)$root,silent=TRUE)
if(class(b20)=='try-error'){
# First attemp: to approximate for limits based on frank copula
dcopula <- dFrank
b20 <- uniroot(Fb20, interval=limits,p2=p2)$root
dcopula <- get(paste0('d',copula))
limits <- c(0.5,2)*b20
b20 <- try(uniroot(Fb20, interval=limits,p2=p2)$root,silent=TRUE)
# Second attemp: search for factible limits
if(class(b20)=='try-error'){
FFB20 <- c()
VALUES <- unique(c(seq(0.1,10,0.1),seq(10,100,1),seq(100,1000,10),seq(1000,10000,100)))
for (i in 1:length(VALUES)) {aux <- try(Fb20(VALUES[i],p2),silent=TRUE); FFB20[i] <- ifelse(class(aux)=='try-error',NA,aux)}
POS_LIMITS <- c(neg=NA,pos=NA)
POS_MIN <- NA
VAL_MIN <- 1000
j <- 1
while(any(is.na(POS_LIMITS)) & j<=length(FFB20)){
if(is.na(FFB20[j])){
POS_LIMITS <- c(neg=NA,pos=NA)
}else if(FFB20[j]<=0){
POS_LIMITS[1] <- j
if(abs(FFB20[j])<VAL_MIN){VAL_MIN <- abs(FFB20[j]);POS_MIN <- j}
}else{
POS_LIMITS[2] <- j
if(abs(FFB20[j])<VAL_MIN){VAL_MIN <- abs(FFB20[j]);POS_MIN <- j}
}
j <- j + 1
}
if(!any(is.na(POS_LIMITS))){
limits <- VALUES[POS_LIMITS]
b20 <- uniroot(Fb20, interval=limits,p2=p2)$root
}else{
b20 <- VALUES[POS_MIN]
cat('Imposed value to b20:',b20,'Parameters:',beta1,beta2,HR1,HR2,p1,p2,case,theta,copula,'\n',file = "log_marginalselection.txt",append=TRUE)
}
}
}
## -- Case 4 --------------------------------------------------------
} else if (case==4) {
x <- c(NA,NA)
# To compute b10
Fb10_case4 <- function(b10,b20,p1){
b10-> x[1]
b20-> x[2]
integral<-integrate(function(u) {
sapply(u, function(u) {
integrate(function(v){dcopula(u,v,theta)}, lower=1-exp(-(x[1]*(-log(1-u))^(1/beta1)/x[2])^beta2), upper=1)$value
})
}, lower= 0 , upper=1-exp(-1/x[1]^beta1))$value
return(integral-p1)
}
# To compute b20
Fb20_case4 <- function(b10,b20,p2) {
b10-> x[1]
b20-> x[2]
integral<-integrate(function(v) {
sapply(v,function(v) {
integrate(function(u){dcopula(u,v,theta)},lower=1-exp(-(x[2]*(-log(1-v))^(1/beta2)/x[1])^beta1), upper=1)$value
})
},
lower= 0, upper=1-exp(-1/x[2]^beta2))$value
return(integral-p2)
}
model <- function(x){
c(Fb10_case4(x[1],x[2],p1), Fb20_case4(x[1],x[2],p2))
}
sol <- multiroot(f = model, start = c(1,1))
sol<-as.data.frame(sol[1])
b10<-sol[1,]
b20<-sol[2,]
}
# Scale parameters for group 1 b11,b21
b11 <- b10/HR1^(1/beta1)
b21 <- b20/HR2^(1/beta2)
# Probabilities p11,p21
#p11 <- 1-exp(-(1/b11)^beta1)
#p21 <- 1-exp(-(1/b21)^beta2)
if(case==1){
p11 <- 1-exp(-(1/b11)^beta1)
p21 <- 1-exp(-(1/b21)^beta2)
}else if(case==2){
p11 <- get_prob1(beta1,beta2,b11,b21,case,rho,copula,endpoint=1)
p21 <- 1-exp(-(1/b21)^beta2)
}else if(case==3){
p11 <- 1-exp(-(1/b11)^beta1)
# cat(beta1,beta2,b11,b21,case,rho,copula,"\n")
p21 <- get_prob1(beta1,beta2,b11,b21,case,rho,copula,endpoint=2) # theta or rho?
}else if(case==4){
p11 <- get_prob1(beta1,beta2,b11,b21,case,rho,copula,endpoint=1)
p21 <- get_prob1(beta1,beta2,b11,b21,case,rho,copula,endpoint=2) # theta or rho?
}
T1dist<-"weibull"
T2dist<-"weibull"
T1pdist<-pweibull
T2pdist<-pweibull
T10param <- list(shape = beta1, scale = b10)
T20param <- list(shape = beta2, scale = b20)
T11param <- list(shape = beta1, scale = b11)
T21param <- list(shape = beta2, scale = b21)
return(list(T1dist,T2dist,T1pdist,T2pdist,T10param,T20param,T11param,T21param,p11,p21))
}
##-- Marginal distribution and parameters
MarginSelec <- MarginalsSelection(beta_e1,beta_e2,HR_e1,HR_e2,p0_e1,p0_e2,case,rho,theta,copula=copula)
#' Marginal distributions for both components
#'
#' @description   Returns the distribution and parameters of the marginal Weibull distributions
#'
#' @param beta1	  Shape parameter for a Weibull law for the relevant event
#' @param beta2   Shape parameter for a Weibull law for the additional event
#' @param HR1     Hazard Ratio for a Weibull law for the relevant event
#' @param HR2     Hazard Ratio for a Weibull law for the additional event
#' @param p1      Proportion of the relevant event expected in group zero
#' @param p2      Proportion of the additional event expected in group zero
#' @param case    Censoring case
#' @param theta   Dependence parameter for the bivariate distribution in control group
#' @param copula  Copula to use
#'
#' @export
#' @keywords internal
#'
#'
MarginalsSelection <- function(beta1,beta2,HR1,HR2,p1,p2,case,rho,theta,copula='Frank')
{
dcopula <- get(paste0('d',copula))
## -- Case 1 --------------------------------------------------------
if(case==1) {
b10 <- 1/((-log(1-p1))^(1/beta1))
b20 <- 1/((-log(1-p2))^(1/beta2))
## -- Case 2 --------------------------------------------------------
}else if (case==2){
Fb10 <- function(b10,p1){
integral<-integrate(function(u) {
sapply(u, function(u) {
integrate(function(v){dcopula(u,v,theta)}, lower=1-exp((b10*(-log(1-u))^(1/beta1))^beta2*log(1-p2)), upper=1)$value
})
}, lower=0 , upper=1-exp(-1/b10^beta1))$value
return(integral-p1)
}
limits <- c(0.00001,10000)                                         # The first and the last values must be in opposite signs for the function
b10 <- try(uniroot(Fb10, interval=limits,p1=p1)$root,silent=TRUE)  # Find the root (value which equals the function zero)
b20 <- 1/(-log(1-p2))^(1/beta2)
if(class(b10)=='try-error'){
dcopula <- dFrank
b10 <- uniroot(Fb10, interval=limits,p1=p1)$root
dcopula <- get(paste0('d',copula))
limits <- c(0.8,1.2)*b10
b10 <- uniroot(Fb10, interval=limits,p1=p1)$root
}
## -- Case 3 --------------------------------------------------------
} else if (case==3) {
b10 <- 1/((-log(1-p1))^(1/beta1))
Fb20 <- function(b20,p2) {
integral<-integrate(function(v) {
sapply(v,function(v) {
integrate(function(u){dcopula(u,v,theta)},lower=1-exp((b20*(-log(1-v))^(1/beta2))^beta1*log(1-p1)),upper=1)$value
})
},
lower=0 , upper=1-exp(-1/b20^beta2))$value
return(integral-p2)
}
limits <- c(0.00001,10000)
b20 <- try(uniroot(Fb20, interval=limits,p2=p2)$root,silent=TRUE)
if(class(b20)=='try-error'){
# First attemp: to approximate for limits based on frank copula
dcopula <- dFrank
b20 <- uniroot(Fb20, interval=limits,p2=p2)$root
dcopula <- get(paste0('d',copula))
limits <- c(0.5,2)*b20
b20 <- try(uniroot(Fb20, interval=limits,p2=p2)$root,silent=TRUE)
# Second attemp: search for factible limits
if(class(b20)=='try-error'){
FFB20 <- c()
VALUES <- unique(c(seq(0.1,10,0.1),seq(10,100,1),seq(100,1000,10),seq(1000,10000,100)))
for (i in 1:length(VALUES)) {aux <- try(Fb20(VALUES[i],p2),silent=TRUE); FFB20[i] <- ifelse(class(aux)=='try-error',NA,aux)}
POS_LIMITS <- c(neg=NA,pos=NA)
POS_MIN <- NA
VAL_MIN <- 1000
j <- 1
while(any(is.na(POS_LIMITS)) & j<=length(FFB20)){
if(is.na(FFB20[j])){
POS_LIMITS <- c(neg=NA,pos=NA)
}else if(FFB20[j]<=0){
POS_LIMITS[1] <- j
if(abs(FFB20[j])<VAL_MIN){VAL_MIN <- abs(FFB20[j]);POS_MIN <- j}
}else{
POS_LIMITS[2] <- j
if(abs(FFB20[j])<VAL_MIN){VAL_MIN <- abs(FFB20[j]);POS_MIN <- j}
}
j <- j + 1
}
if(!any(is.na(POS_LIMITS))){
limits <- VALUES[POS_LIMITS]
b20 <- uniroot(Fb20, interval=limits,p2=p2)$root
}else{
b20 <- VALUES[POS_MIN]
cat('Imposed value to b20:',b20,'Parameters:',beta1,beta2,HR1,HR2,p1,p2,case,theta,copula,'\n',file = "log_marginalselection.txt",append=TRUE)
}
}
}
## -- Case 4 --------------------------------------------------------
} else if (case==4) {
x <- c(NA,NA)
# To compute b10
Fb10_case4 <- function(b10,b20,p1){
b10-> x[1]
b20-> x[2]
integral<-integrate(function(u) {
sapply(u, function(u) {
integrate(function(v){dcopula(u,v,theta)}, lower=1-exp(-(x[1]*(-log(1-u))^(1/beta1)/x[2])^beta2), upper=1)$value
})
}, lower= 0 , upper=1-exp(-1/x[1]^beta1))$value
return(integral-p1)
}
# To compute b20
Fb20_case4 <- function(b10,b20,p2) {
b10-> x[1]
b20-> x[2]
integral<-integrate(function(v) {
sapply(v,function(v) {
integrate(function(u){dcopula(u,v,theta)},lower=1-exp(-(x[2]*(-log(1-v))^(1/beta2)/x[1])^beta1), upper=1)$value
})
},
lower= 0, upper=1-exp(-1/x[2]^beta2))$value
return(integral-p2)
}
model <- function(x){
c(Fb10_case4(x[1],x[2],p1), Fb20_case4(x[1],x[2],p2))
}
sol <- multiroot(f = model, start = c(1,1))
sol<-as.data.frame(sol[1])
b10<-sol[1,]
b20<-sol[2,]
}
# Scale parameters for group 1 b11,b21
b11 <- b10/HR1^(1/beta1)
b21 <- b20/HR2^(1/beta2)
# Probabilities p11,p21
#p11 <- 1-exp(-(1/b11)^beta1)
#p21 <- 1-exp(-(1/b21)^beta2)
if(case==1){
p11 <- 1-exp(-(1/b11)^beta1)
p21 <- 1-exp(-(1/b21)^beta2)
}else if(case==2){
p11 <- get_prob1(beta1,beta2,b11,b21,case,rho,copula,endpoint=1)
p21 <- 1-exp(-(1/b21)^beta2)
}else if(case==3){
p11 <- 1-exp(-(1/b11)^beta1)
# cat(beta1,beta2,b11,b21,case,rho,copula,"\n")
p21 <- get_prob1(beta1,beta2,b11,b21,case,rho,copula,endpoint=2) # theta or rho?
}else if(case==4){
p11 <- get_prob1(beta1,beta2,b11,b21,case,rho,copula,endpoint=1)
p21 <- get_prob1(beta1,beta2,b11,b21,case,rho,copula,endpoint=2) # theta or rho?
}
T1dist<-"weibull"
T2dist<-"weibull"
T1pdist<-pweibull
T2pdist<-pweibull
T10param <- list(shape = beta1, scale = b10)
T20param <- list(shape = beta2, scale = b20)
T11param <- list(shape = beta1, scale = b11)
T21param <- list(shape = beta2, scale = b21)
return(list(T1dist,T2dist,T1pdist,T2pdist,T10param,T20param,T11param,T21param,p11,p21))
}
rho=0.3
##-- Marginal distribution and parameters
MarginSelec <- MarginalsSelection(beta_e1,beta_e2,HR_e1,HR_e2,p0_e1,p0_e2,case,rho,theta,copula=copula)
#'
#' The user can choose between the two most common formulae (Schoendfeld and Freedman) for the sample size calculation for the single components.
#' Schoendfeld formula always be used for the composite endpoint.
#'
#'
#' @references
#' Friedman L.M., Furberg C.D., DeMets D.L. Fundamentals of Clinical Trials. 3rd ed. New York: Springer; 1998.
#' Cortés Martínez, J., Geskus, R.B., Kim, K. et al. Using the geometric average hazard ratio in sample size calculation for time-to-event data with composite endpoints. BMC Med Res Methodol 21, 99 (2021). https://doi.org/10.1186/s12874-021-01286-x
#'
#'
samplesize_tte <- function(p0_e1, p0_e2, HR_e1, HR_e2, beta_e1=1, beta_e2=1,
case, copula = 'Frank', rho=0.3, rho_type='Spearman',
alpha=0.05, power=0.80 ,ss_formula='schoendfeld',
subdivisions=50, plot_res=FALSE, plot_store=FALSE){
cat('test_1')
requireNamespace("stats")
if(p0_e1 < 0 || p0_e1 > 1){
stop("The probability of observing the event E1 (p_e1) must be a number between 0 and 1")
}else if(p0_e2 < 0 || p0_e2 > 1){
stop("The probability of observing the event E2 (p_e2) must be a number between 0 and 1")
}else if(HR_e1 < 0 || HR_e1 > 1){
stop("The hazard ratio for the relevant endpoint E1 (HR_e1) must be a number between 0 and 1")
}else if(HR_e2 < 0 || HR_e2 > 1){
stop("The hazard ratio for the secondary endpoint E2 (HR_e2) must be a number between 0 and 1")
}else if(beta_e1 <= 0){
stop("The shape parameter for the marginal weibull distribution of the relevant endpoint E1 (beta_e1) must be a positive number")
}else if(beta_e2 <= 0){
stop("The shape parameter for the marginal weibull distribution of the secondary endpoint E2 (beta_e2) must be a positive number")
}else if(!case %in% 1:4){
stop("The case (case) must be a number in {1,2,3,4}. See ?effectsize_tte")
}else if(!copula %in% c('Frank','Gumbel','Clayton')){
stop("The copula (copula) must be one of 'Frank','Gumbel','Clayton'")
}else if(rho < -1 || rho > 1){
stop("The correlation (rho) must be a number between -1 and 1")
}else if(!rho_type %in% c('Spearman','Kendall')){
stop("The correlation type (rho_type) must be one of 'Spearman' or 'Kendall'")
}else if(alpha<=0 || alpha>=1){
stop("The probability of type I error (alpha) must be a numeric value between 0 and 1")
}else if(power<=0 || power>=1){
stop("The power must be a numeric value between 0 and 1")
}else if(!ss_formula %in% c('schoendfeld','freedman')){
stop("The selected formula (ss_formula) must be one of 'schoendfeld' (default) or 'freedman'")
}else if(!is.logical(plot_res)){
stop("The parameter plot_res must be logical")
}else if(!is.logical(plot_store)){
stop("The parameter plot_store must be logical")
}
# Values of rho where to calculate Sample size
rho_sel <- rho
if(plot_res | plot_store){
rho_seq <- unique(c(rho,seq(0.01,0.98,length=subdivisions)))
}else{
rho_seq <- rho
}
# Storage
SS_array_1 <- SS_array_2 <- SS_array_c <- c()
# Calculate Sample size for each rho
pb = txtProgressBar(min = 0, max = length(rho_seq), initial = 0)
for(rho in rho_seq){
setTxtProgressBar(pb,which(rho_seq==rho))
##-- Effect size
invisible(capture.output(eff_size <- effectsize_tte(p0_e1, p0_e2, HR_e1, HR_e2, beta_e1, beta_e2, case, copula, rho, rho_type, subdivisions=1000,plot_res = FALSE)))
gAHR <- eff_size$effect_size$gAHR
##-- Events
events_1 <- ifelse(ss_formula=='schoendfeld',
schoendfeld_formula(alpha,power,HR_e1),
freedman_formula(alpha,power,HR_e1))
events_2 <- ifelse(ss_formula=='schoendfeld',
schoendfeld_formula(alpha,power,HR_e2),
freedman_formula(alpha,power,HR_e2))
events_c <- schoendfeld_formula(alpha,power,gAHR)
##-- Probabilities of observing the event
p1_e1 <- eff_size$measures_by_group$p_e1[2]
p1_e2 <- eff_size$measures_by_group$p_e2[2]
p0_star <- eff_size$measures_by_group$pstar[1]
p1_star <- eff_size$measures_by_group$pstar[2]
##-- Sample size
ss_1 <- as.numeric(2*ceiling(events_1/(p0_e1 + p1_e1)))
ss_2 <- as.numeric(2*ceiling(events_2/(p0_e2 + p1_e2)))
ss_c <- as.numeric(2*ceiling(events_c/(p0_star + p1_star)))
SS_array_1 <- c(SS_array_1,ss_1)
SS_array_2 <- c(SS_array_2,ss_2)
SS_array_c <- c(SS_array_c,ss_c)
}
if(plot_res | plot_store){
dd <- data.frame(rho=rho_seq, sample_size=SS_array_c)
gg1 <- ggplot(dd,aes(x=rho,y=sample_size)) +
geom_line(color='darkblue',size=1.3) +
xlab(expression(rho)) + ylab('Sample size CE')
}
##-- Output data.frame
df <- data.frame(Endpoint=c('--------','Endpoint 1','Endpoint 2','Composite endpoint'),
"Total sample size"=c("-----------------",SS_array_1[1],SS_array_2[1],SS_array_c[1]),
check.names = FALSE)
print(df, row.names = FALSE,right=FALSE)
return_object <- list('ss_E1'     = SS_array_1[1],
'ss_E2'     = SS_array_2[1],
'ss_Ec'     = SS_array_c[1],
'gg_object' = NA)
## Print graphic
if(plot_res) print(gg1)
## Store plot in the output
if(plot_store) return_object$gg_object <- gg1
##-- Returned list
return(invisible(return_object))
}
#########################
# Sample size
#########################
a <- samplesize_tte(p0_e1, p0_e2, HR_e1, HR_e2, beta_e1=1, beta_e2=1, case, copula = 'Frank',
rho=0.3, rho_type='Spearman', alpha=0.05, power=0.80 ,ss_formula='schoendfeld',
plot_res = FALSE, plot_store=FALSE)
library(devtools)
# To create a new package
# usethis::create_package("~/Desktop/CompARE")
setwd("C:/Users/jordi/My Drive/CompARE package/CompARE-package/CompARE-package")
setwd("C:/Users/jcortes/My Drive/CompARE package/CompARE-package/CompARE-package")
devtools::document()
devtools::load_all()
#########################
# Sample size
#########################
a <- samplesize_tte(p0_e1, p0_e2, HR_e1, HR_e2, beta_e1=1, beta_e2=1, case, copula = 'Frank',
rho=0.3, rho_type='Spearman', alpha=0.05, power=0.80 ,ss_formula='schoendfeld',
plot_res = FALSE, plot_store=FALSE)
a$gg_object
#########################
# ARE
#########################
a <- ARE_tte(p0_e1=p1, p0_e2=p2, HR_e1=HR1, HR_e2=HR2, beta_e1=beta1, beta_e2=beta2,
case = case, rho=rho, copula = copula, rho_type=rho_type,
plot_res = FALSE, plot_store=FALSE)
library(devtools)
# To create a new package
# usethis::create_package("~/Desktop/CompARE")
setwd("C:/Users/jordi/My Drive/CompARE package/CompARE-package/CompARE-package")
setwd("C:/Users/jcortes/My Drive/CompARE package/CompARE-package/CompARE-package")
devtools::document()
devtools::load_all()
#########################
# ARE
#########################
a <- ARE_tte(p0_e1=p1, p0_e2=p2, HR_e1=HR1, HR_e2=HR2, beta_e1=beta1, beta_e2=beta2,
case = case, rho=rho, copula = copula, rho_type=rho_type,
plot_res = FALSE, plot_store=FALSE)
a$gg_object
#########################
# Surv_tte
#########################
a <- surv_tte(p0_e1, p0_e2, HR_e1, HR_e2, beta_e1=1, beta_e2=1, case, copula = 'Frank', rho=0.3, rho_type='Spearman',
plot_res=TRUE, plot_store=TRUE,followup_time = 2)
library(devtools)
# To create a new package
# usethis::create_package("~/Desktop/CompARE")
setwd("C:/Users/jordi/My Drive/CompARE package/CompARE-package/CompARE-package")
setwd("C:/Users/jcortes/My Drive/CompARE package/CompARE-package/CompARE-package")
devtools::document()
devtools::load_all()
#########################
# Surv_tte
#########################
a <- surv_tte(p0_e1, p0_e2, HR_e1, HR_e2, beta_e1=1, beta_e2=1, case, copula = 'Frank', rho=0.3, rho_type='Spearman',
plot_res=TRUE, plot_store=TRUE,followup_time = 2)
#########################
# Effect size
#########################
# p0_e1=p1; p0_e2=p2; HR_e1=HR1; HR_e2=HR2; beta_e1=beta1; beta_e2=beta2; case = case; rho=rho; copula = copula; rho_type='Spearman'
a <- effectsize_tte(p0_e1=p1, p0_e2=p2, HR_e1=HR1, HR_e2=HR2, beta_e1=beta1, beta_e2=beta2,
case = case, rho=rho, copula = copula, rho_type='Spearman',
followup_time=4,
plot_res=TRUE, plot_store=FALSE)
#########################
# plot
#########################
plot_tte(p0_e1=p1, p0_e2=p2, HR_e1=HR1, HR_e2=HR2, beta_e1=beta1, beta_e2=beta2,
case = case, rho=rho, copula = copula, rho_type=rho_type,
followup_time=1,
alpha=0.05, power=0.80 , ss_formula='schoendfeld')
#########################
# Sample size
#########################
a <- samplesize_tte(p0_e1, p0_e2, HR_e1, HR_e2, beta_e1=1, beta_e2=1, case, copula = 'Frank',
rho=0.3, rho_type='Spearman', alpha=0.05, power=0.80 ,ss_formula='schoendfeld',
plot_res = FALSE, plot_store=FALSE)
#########################
# ARE
#########################
a <- ARE_tte(p0_e1=p1, p0_e2=p2, HR_e1=HR1, HR_e2=HR2, beta_e1=beta1, beta_e2=beta2,
case = case, rho=rho, copula = copula, rho_type=rho_type,
plot_res = FALSE, plot_store=FALSE)
#########################
# Surv_tte
#########################
a <- surv_tte(p0_e1, p0_e2, HR_e1, HR_e2, beta_e1=1, beta_e2=1, case, copula = 'Frank', rho=0.3, rho_type='Spearman',
plot_res=TRUE, plot_store=TRUE,followup_time = 2)
a$gg_object
#########################
# Effect size
#########################
# p0_e1=p1; p0_e2=p2; HR_e1=HR1; HR_e2=HR2; beta_e1=beta1; beta_e2=beta2; case = case; rho=rho; copula = copula; rho_type='Spearman'
a <- effectsize_tte(p0_e1=p1, p0_e2=p2, HR_e1=HR1, HR_e2=HR2, beta_e1=beta1, beta_e2=beta2,
case = case, rho=rho, copula = copula, rho_type='Spearman',
followup_time=4,
plot_res=TRUE, plot_store=FALSE)
library(devtools)
# To create a new package
# usethis::create_package("~/Desktop/CompARE")
setwd("C:/Users/jordi/My Drive/CompARE package/CompARE-package/CompARE-package")
setwd("C:/Users/jcortes/My Drive/CompARE package/CompARE-package/CompARE-package")
devtools::document()
devtools::load_all()
rm(list = c("MarginalsSelection", "samplesize_tte"))
library(devtools)
# To create a new package
# usethis::create_package("~/Desktop/CompARE")
setwd("C:/Users/jordi/My Drive/CompARE package/CompARE-package/CompARE-package")
setwd("C:/Users/jcortes/My Drive/CompARE package/CompARE-package/CompARE-package")
devtools::document()
devtools::load_all()
#########################
# plot
#########################
plot_tte(p0_e1=p1, p0_e2=p2, HR_e1=HR1, HR_e2=HR2, beta_e1=beta1, beta_e2=beta2,
case = case, rho=rho, copula = copula, rho_type=rho_type,
followup_time=1,
alpha=0.05, power=0.80 , ss_formula='schoendfeld')
